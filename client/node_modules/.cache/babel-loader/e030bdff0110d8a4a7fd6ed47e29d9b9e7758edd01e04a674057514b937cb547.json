{"ast":null,"code":"import axios from 'axios';\n\n// Base URL for India Code API\nconst INDIA_CODE_API_BASE = 'https://api.indiacode.nic.in/api/v1';\n\n/**\r\n * Fetch citation details for a specific law section\r\n * @param {string} actId - The ID of the act/law\r\n * @param {string} sectionId - The section number\r\n * @returns {Promise<Object>} - Citation details\r\n */\nexport const fetchCitation = async (actId, sectionId) => {\n  // In a real implementation, this would fetch from an API\n  // For now, we'll return mock data\n  await new Promise(resolve => setTimeout(resolve, 800)); // Simulate network delay\n\n  return {\n    id: `${actId}-${sectionId}`,\n    title: `Section ${sectionId}`,\n    actName: decodeURIComponent(actId),\n    sectionNumber: sectionId,\n    year: \"2023\",\n    text: `This is a mock legal text for ${decodeURIComponent(actId)}, Section ${sectionId}. In a real implementation, this would contain the actual legal text from the Indian legal database or India Code API.`,\n    url: `https://www.indiacode.nic.in/acts/${actId}/sections/${sectionId}`\n  };\n};\n\n/**\r\n * Search for relevant legal sections based on keywords\r\n * @param {string} query - Search query\r\n * @returns {Promise<Array>} - List of relevant legal sections\r\n */\nexport const searchLegalSections = async query => {\n  try {\n    const response = await axios.get(`${INDIA_CODE_API_BASE}/search`, {\n      params: {\n        q: query,\n        limit: 5\n      }\n    });\n    return response.data.results;\n  } catch (error) {\n    console.error('Error searching legal sections:', error);\n    return [];\n  }\n};\n\n/**\r\n * Format a citation for display\r\n * @param {Object} citation - Citation data\r\n * @returns {Object} - Formatted citation for display\r\n */\nexport const formatCitation = citation => {\n  var _citation$act, _citation$act2;\n  if (!citation) return null;\n  return {\n    id: citation.id,\n    title: citation.title || 'Unknown Title',\n    actName: citation.actName || ((_citation$act = citation.act) === null || _citation$act === void 0 ? void 0 : _citation$act.name) || 'Unknown Act',\n    sectionNumber: citation.sectionNumber || citation.number || 'N/A',\n    year: citation.year || ((_citation$act2 = citation.act) === null || _citation$act2 === void 0 ? void 0 : _citation$act2.year) || 'N/A',\n    url: citation.url || `${INDIA_CODE_API_BASE}/acts/${citation.actId}/sections/${citation.id}`,\n    text: citation.text || citation.content || 'No content available',\n    formattedCitation: `${citation.actName || 'Act'} (${citation.year || 'N/A'}), Section ${citation.sectionNumber || 'N/A'}`\n  };\n};\n\n/**\r\n * Extract citation references from AI response\r\n * @param {string} text - AI generated response text\r\n * @returns {Array<Object>} - List of citation references\r\n */\nexport const extractCitationReferences = text => {\n  // Basic regex to find citation patterns like \"Section X of Act Y\"\n  const sectionRegex = /Section\\s+(\\d+[A-Z]?(?:-\\d+)?)\\s+of\\s+(?:the\\s+)?([^,.]+)/gi;\n\n  // Find all matches\n  const matches = [...text.matchAll(sectionRegex)];\n\n  // Format matches into citation objects\n  return matches.map((match, index) => {\n    return {\n      id: `ref-${index}`,\n      referenceId: `citation-${index}`,\n      sectionNumber: match[1],\n      actName: match[2].trim(),\n      fullMatch: match[0]\n    };\n  });\n};\n\n/**\r\n * Enhance text with citation links\r\n * @param {string} text - Original text\r\n * @param {Array<Object>} citations - List of citations\r\n * @returns {Object} - Text with citation markers and citation objects\r\n */\nexport const enhanceTextWithCitations = (text, citations) => {\n  let enhancedText = text;\n  const citationObjects = [];\n  if (citations && citations.length > 0) {\n    // Replace citation references with markers\n    citations.forEach((citation, index) => {\n      const marker = `[${index + 1}]`;\n      enhancedText = enhancedText.replace(citation.fullMatch, `${citation.fullMatch} ${marker}`);\n      citationObjects.push({\n        ...citation,\n        markerText: marker\n      });\n    });\n  }\n  return {\n    enhancedText,\n    citations: citationObjects\n  };\n};","map":{"version":3,"names":["axios","INDIA_CODE_API_BASE","fetchCitation","actId","sectionId","Promise","resolve","setTimeout","id","title","actName","decodeURIComponent","sectionNumber","year","text","url","searchLegalSections","query","response","get","params","q","limit","data","results","error","console","formatCitation","citation","_citation$act","_citation$act2","act","name","number","content","formattedCitation","extractCitationReferences","sectionRegex","matches","matchAll","map","match","index","referenceId","trim","fullMatch","enhanceTextWithCitations","citations","enhancedText","citationObjects","length","forEach","marker","replace","push","markerText"],"sources":["D:/Legal Assistant for Indian Laws/client/src/services/citationService.js"],"sourcesContent":["import axios from 'axios';\r\n\r\n// Base URL for India Code API\r\nconst INDIA_CODE_API_BASE = 'https://api.indiacode.nic.in/api/v1';\r\n\r\n/**\r\n * Fetch citation details for a specific law section\r\n * @param {string} actId - The ID of the act/law\r\n * @param {string} sectionId - The section number\r\n * @returns {Promise<Object>} - Citation details\r\n */\r\nexport const fetchCitation = async (actId, sectionId) => {\r\n  // In a real implementation, this would fetch from an API\r\n  // For now, we'll return mock data\r\n  await new Promise(resolve => setTimeout(resolve, 800)); // Simulate network delay\r\n  \r\n  return {\r\n    id: `${actId}-${sectionId}`,\r\n    title: `Section ${sectionId}`,\r\n    actName: decodeURIComponent(actId),\r\n    sectionNumber: sectionId,\r\n    year: \"2023\",\r\n    text: `This is a mock legal text for ${decodeURIComponent(actId)}, Section ${sectionId}. In a real implementation, this would contain the actual legal text from the Indian legal database or India Code API.`,\r\n    url: `https://www.indiacode.nic.in/acts/${actId}/sections/${sectionId}`\r\n  };\r\n};\r\n\r\n/**\r\n * Search for relevant legal sections based on keywords\r\n * @param {string} query - Search query\r\n * @returns {Promise<Array>} - List of relevant legal sections\r\n */\r\nexport const searchLegalSections = async (query) => {\r\n  try {\r\n    const response = await axios.get(`${INDIA_CODE_API_BASE}/search`, {\r\n      params: { q: query, limit: 5 }\r\n    });\r\n    return response.data.results;\r\n  } catch (error) {\r\n    console.error('Error searching legal sections:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n/**\r\n * Format a citation for display\r\n * @param {Object} citation - Citation data\r\n * @returns {Object} - Formatted citation for display\r\n */\r\nexport const formatCitation = (citation) => {\r\n  if (!citation) return null;\r\n  \r\n  return {\r\n    id: citation.id,\r\n    title: citation.title || 'Unknown Title',\r\n    actName: citation.actName || citation.act?.name || 'Unknown Act',\r\n    sectionNumber: citation.sectionNumber || citation.number || 'N/A',\r\n    year: citation.year || citation.act?.year || 'N/A',\r\n    url: citation.url || `${INDIA_CODE_API_BASE}/acts/${citation.actId}/sections/${citation.id}`,\r\n    text: citation.text || citation.content || 'No content available',\r\n    formattedCitation: `${citation.actName || 'Act'} (${citation.year || 'N/A'}), Section ${citation.sectionNumber || 'N/A'}`\r\n  };\r\n};\r\n\r\n/**\r\n * Extract citation references from AI response\r\n * @param {string} text - AI generated response text\r\n * @returns {Array<Object>} - List of citation references\r\n */\r\nexport const extractCitationReferences = (text) => {\r\n  // Basic regex to find citation patterns like \"Section X of Act Y\"\r\n  const sectionRegex = /Section\\s+(\\d+[A-Z]?(?:-\\d+)?)\\s+of\\s+(?:the\\s+)?([^,.]+)/gi;\r\n  \r\n  // Find all matches\r\n  const matches = [...text.matchAll(sectionRegex)];\r\n  \r\n  // Format matches into citation objects\r\n  return matches.map((match, index) => {\r\n    return {\r\n      id: `ref-${index}`,\r\n      referenceId: `citation-${index}`,\r\n      sectionNumber: match[1],\r\n      actName: match[2].trim(),\r\n      fullMatch: match[0]\r\n    };\r\n  });\r\n};\r\n\r\n/**\r\n * Enhance text with citation links\r\n * @param {string} text - Original text\r\n * @param {Array<Object>} citations - List of citations\r\n * @returns {Object} - Text with citation markers and citation objects\r\n */\r\nexport const enhanceTextWithCitations = (text, citations) => {\r\n  let enhancedText = text;\r\n  const citationObjects = [];\r\n\r\n  if (citations && citations.length > 0) {\r\n    // Replace citation references with markers\r\n    citations.forEach((citation, index) => {\r\n      const marker = `[${index + 1}]`;\r\n      enhancedText = enhancedText.replace(\r\n        citation.fullMatch,\r\n        `${citation.fullMatch} ${marker}`\r\n      );\r\n      \r\n      citationObjects.push({\r\n        ...citation,\r\n        markerText: marker\r\n      });\r\n    });\r\n  }\r\n  \r\n  return {\r\n    enhancedText,\r\n    citations: citationObjects\r\n  };\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}